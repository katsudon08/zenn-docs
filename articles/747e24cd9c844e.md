---
title: "【React基礎】レンダリングは「計算」であるべき。不具合を生まないコンポーネント設計"
emoji: "⚠️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["React", "初心者", "フロントエンド"]
published: true
---
# 1.はじめに
プログラミングの世界には「**純粋関数**」という言葉があります。
純粋関数というのは、以下の2つの性質を持つ関数のことです。

- **同じ入力**に対して**同じ出力**を返す
- **外部の変数や状態**などを変更しない

少し難しく聞こえるかもしれませんが、Reactの設計はこの「純粋関数」の思想に基づいて成り立っています。

そんなReactの基本思想である「純粋さ」について、今回は解説していきたいと思います！

# 2.純粋関数とは何か？
先ほども軽く触れたこの純粋関数。

Reactが求める「純粋さ」には、大きく分けて2つの鉄則があります。
この2つを守っている限り、そのコンポーネントは安全であるといえます。

**ルール1：同じ入力には、同じ出力を返す**
純粋な関数は、何度呼び出しても同じ引数（Props）を渡せば必ず同じ結果（JSX）を返します。

例えば、数学の`2 + 2`は、いつ計算しても必ず`4`になりますよね！
これと同じことがコンポーネントについても起きるようになります。

```ts
interface RecipeProps {
    drinkers: number;
}

// ⭕️ 純粋：Props が同じなら常に結果も同じ
function Recipe({ drinkers }: RecipeProps) {
    return (
        <ol>
            <li>水：{2 * drinkers} カップ</li>
            <li>スパイス：{0.5 * drinkers} スプーン</li>
        </ol>
    );
}
```

:::message
関数の中で、`Math.random()`や`new Date()`を使うと、実行するたびに結果が変わってしまうため、そのコンポーネントは「**不純**」になってしまいます！
:::

**ルール2：自身のスコープ外にあるものを書き換えない（副作用を持たない）**
純粋な関数は、呼び出される前に存在していた変数やオブジェクトを勝手に書き換えたりしません。

「自分の仕事だけに集中し、他人の領域を汚さない」のがイメージです！

- **純粋なコンポーネント**は、ジュースの抽出機のようなものです。材料（**Props**）を入れると、おいしいジュース（**JSX**）が出てきます。
抽出している最中に、勝手にキッチンの壁を塗り替えたり、冷蔵庫の中身を捨てたり（**外部の書き換え**）はしません。

- **不純なコンポーネント**は、ジュースを作っている途中で勝手に掃除をしたり、部屋の模様替えをしてしまう抽出器のようなものです。
これでは、何が起こるかわからず、安心して使えませんよね。

# 3.【アンチパターン】レンダリング中の副作用
Reactの世界において、最も避けるべきなのは「**レンダリングという計算の最中に、外の世界を書き換えてしまう**」ことです。
これを「**副作用**」と呼びます。

具体的に、何がよくないのか見ていきましょう。

以下のコードは、一見すると呼び出すたびにゲスト番号が増えていく便利なコンポーネントに見えます。

```ts
// ❌ 絶対にやってはいけない書き方
let guestCount = 0;

function Cup() {
    // レンダリング（計算）の最中に、外にある変数を書き換えている
    guestCount += 1;
    return (
        <h2>ゲスト #{ guestCount } のティーカップ</h2>
    );
}

export default function TeaList() {
    return (
        <>
            <Cup />
            <Cup />
            <Cup />
        </>
    );
}
```

このコンポーネントを画面にレンダリングすると、期待通り「ゲスト #1」「ゲスト #2」「ゲスト #3」と表示される**かもしれません**。
しかし、これは非常に危険で不安定な状態です。

### なぜこれがダメなのでしょうか？

Reactは、コンポーネントを「いつ」「どの順番で」呼び出すかを自由に決定します。

1. **順番が変わるかもしれない**
Reactが先に「3番目の`Cup`を計算しよう」と判断したら、番号がバラバラになってしまいます。

2. **スキップされるかもしれない**
すでに表示済みのパーツなら、Reactは計算をスキップして不可を軽減しようとします。
すると、こちらが想定していたレンダリング時にカウントが増える動作が働かず、`guestCount`が増えません。

3. **2回実行されるかもしれない**
これが一番重要な内容です。詳しく解説していきます。

Reactの開発環境では、`Strict Mode`という機能がデフォルトで有効になっています。
このモードでは、「**あなたのコンポーネントが純粋であるかどうか**」をチェックするために、各コンポーネントをあえて**2回ずつ**呼び出します。

もし、コンポーネントが純粋ならば、2回呼び出そうと結果は変わりません。
しかし、上記の`Cup`のようなコードのような場合、1回画面に出そうとするだけで`getCount`が2回増えてしまい、表示が「#2」「#4」「#6」ととびとびになってしまいます。（本来はインクリメントのように1つずつ増加する形を想定しているのに）

ただ、`Strict Mode`は開発環境でのみ有効で、本番環境では動作しません。
ですので、開発中に作成したコンポーネントが**純粋かどうか**を教えてくれる実はうれしい機能ではあります。

# 4.副作用はどこに書くべきか？
ここまで、副作用が悪のような書き方をしてきましたが、必ずしもそうというわけではありません。
そもそもアプリを作っていく中で、外部とのやり取りが発生するというのは必然だと思います。

では、どうすればいいのか。

その答えは**レンダリングの「外」で行う**です。

主に副作用を記述する場所は2つあります。

**1.イベントハンドラ**
ボタンをクリックしたときや、フォームを送信したときなど、「**ユーザーの操作**」に応じて何かを起こしたい場合は、イベントハンドラの中に書きます。

以下、具体例です。

```ts
function handleClick() {
    // ✅ ここは副作用の「安全地帯」！
    // 外部の変数を変えたり、APIを叩いたりしてもOKです。
    alert("申し込みが完了しました");
}

return <button onClick={handleClick}>申し込む</button>;
```

イベントハンドラは、コンポーネントの中に定義されていますが、**レンダリングの最中には実行されません**。
そのため、ここがどれだけ「**不純**」であっても、Reactのレンダリングルールを壊すことはありません。

**2.useEffect（最終手段）**
「画面が表示された直後にAPIからデータを取得した」など、ユーザーの操作ではなく、「**レンダリングの結果として発生する副作用**」が必要な場合は、`useEffect`というフックを使います。

```ts
useEffect(() => {
    // ✅ これはレンダリングの「後」に実行されます
    console.log("画面が表示されました");
}, []);
```

:::details フックとは？
Reactにおける状態管理などの機能を、クラスを書かずに使えるようになる機能のことです。

Reactは以前クラスコンポーネントで書くのが一般的でした。
その際に扱えていた状態管理やライフサイクルの機能を関数コンポーネントでも扱えるようにしたのが、このフックです。

後々、別の記事できちんと解説したいと思います！
:::

ただし、`useEffect`は副作用を扱うための「最終手段」です。
可能な限り、ロジックはイベントハンドラの中で完結させられないか検討しましょう！

# 5.まとめ
Reactにおいてコンポーネントを純粋に保つことは、単なる推奨ルールではなく、「**堅牢で予測可能なコード**」を書くための基盤です。

これにより、どこで動かしても同じ結果を得ることができ、計算を途中でやめたり再開しても、結果にずれが生じることなく、パフォーマンスの向上にもつながります。

また、開発中に`Strict Mode`で表示が想定から崩れたなら、それはバグではなく、将来の大きな問題を事前に防ぐための「ヒント」です！
副作用を正しい場所に配置して、クリーンなコンポーネントを保つように気を付けましょう！

# 6.参考
- [コンポーネントを純粋に保つ](https://ja.react.dev/learn/keeping-components-pure)