---
title: "FSDにおけるsharedとindex.tsの正しい設計 ─ スライスを持たないレイヤーの扱い方"
emoji: "🧱"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["FSD", "アーキテクチャ", "フロントエンド", "TypeScript", "設計"]
published: true
---

::: message
本記事はAIと共同で執筆を行っています。
誤りや、不明瞭な点がありましたらぜひご指摘ください😿
:::

## はじめに

**Feature-Sliced-Design（以下 FSD）** を採用して設計を進めていくと、  
多くの人が一度は次の疑問にぶつかります。

> **「shared レイヤーに index.ts は置くべきなのか？」**

一見すると単純な barrel export の話に見えますが、  
この問いは **FSDのレイヤー構造・責務分離・Public API の考え方** を正しく理解していないと、  
簡単に誤った設計へ進んでしまいます。

本記事では、

- FSDの正確な用語整理  
- shared レイヤーの特殊性  
- index.ts を「どこに・なぜ」置くべきか  

を整理し、**shared における index.ts の正解**を明確にします。

---

## FSDの用語を正確に整理する

まず混乱しやすい用語を、FSDの定義に沿って整理します。

### レイヤー（Layer）
依存方向を定義する最上位構造です。

```

app → pages → widgets → features → entities → shared

```

- 上位レイヤーは下位レイヤーにのみ依存可能
- 依存制約を担う構造単位

---

### スライス（Slice）
**レイヤー直下に存在する、意味（ドメイン）を持つ単位**です。

例：

```

features/
├ login
├ signup

entities/
├ user
├ article

```

- スライスは **Public API を持つ**
- 原則としてスライス間依存は禁止
- FSDで最も重要な設計単位

---

### セグメント（Segment）
スライス内部の **技術的な役割分割** です。

```

features/login/
├ ui
├ model
├ api

````

- `ui / model / api / lib` など
- 依存制約を表す単位ではない
- 外部公開を前提としない

---

## shared レイヤーの特殊性

ここが本記事の核心です。

### shared の特徴

- **スライスを持たない**
- ドメイン・意味を持たない
- 全レイヤーから利用される最下層
- UIプリミティブ、util、config などの集合

つまり shared は、

> **「Public API を定義する主体ではない」**

という点が極めて重要です。

---

## index.ts の本来の役割

`index.ts`（barrel file）の役割はただ一つです。

> **その単位が、外部に何を公開するかを定義すること**

FSDではこの「外部に公開する単位」は  
**スライス**であることが原則です。

---

## なぜ shared/index.ts を置いてはいけないのか

### ❌ shared レイヤー直下

```text
shared/
 ├ ui/
 ├ lib/
 ├ api/
 └ index.ts   // ❌ 非推奨
````

#### 問題点

* shared 自体は責務を持たない
* Public API の境界が存在しない
* shared 全体が一つの巨大APIになる
* import から意味が消える

```ts
// 悪い例
import { Button, formatDate, apiClient } from '@/shared';
```

これは **FSDの思想と真っ向から衝突**します。

---

## shared で index.ts を置いてよい場所（結論）

### 結論を一文で

> **shared では「モジュール（最小責務単位）」にのみ index.ts を置く**

---

### ✅ 推奨される構成

```text
shared/
 ├ ui/
 │  ├ button/
 │  │  ├ Button.tsx
 │  │  └ index.ts   // ✅ OK
 │  └ modal/
 │     └ index.ts   // ✅ OK
 ├ lib/
 │  └ date/
 │     └ index.ts   // ✅ OK
```

```ts
import { Button } from '@/shared/ui/button';
import { formatDate } from '@/shared/lib/date';
```

#### なぜ OK なのか

* `button` や `date` は **単一責務**
* Public API を定義できる明確な境界
* import パスに責務がそのまま現れる

---

## 条件付きで許容される例外

### shared/config のような「閉じた集合」

```text
shared/
 └ config/
    ├ env.ts
    └ index.ts   // ⚠️ 条件付きOK
```

#### 許容条件

* 完全に安定している
* 今後ほぼ増減しない
* 設定値・型定義のみ
* 技術的に一体として扱われる

```ts
import { appConfig } from '@/shared/config';
```

---

## まとめ：shared における index.ts の最終ルール

| 置き場所                        | 判断      |
| --------------------------- | ------- |
| `shared/index.ts`           | ❌ 置かない  |
| `shared/ui/index.ts`        | ❌ 原則不要  |
| `shared/ui/button/index.ts` | ✅ 推奨    |
| `shared/lib/date/index.ts`  | ✅ 推奨    |
| `shared/config/index.ts`    | ⚠️ 条件付き |

---

## おわりに

FSDにおいて重要なのは、「短く import できるか」ではなく **「構造が設計を正しく語っているか」** です。

shared は便利なレイヤーであるがゆえに、
一度設計を誤ると **最も腐りやすい場所** でもあります。

ぜひ、

> **「shared は Public API を持たない」**

という前提を忘れず、**最小責務単位でのみ index.ts を置く設計** を意識してみてください。

この記事が、FSDにおける shared 設計の判断軸になれば幸いです。