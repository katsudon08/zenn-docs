---
title: "TypeScriptのPartial型を正しく理解する ― 更新処理とComputed Property Namesまで"
emoji: "🧩"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["typescript", "javascript", "型安全", "設計"]
published: true
---

::: message
本記事はAIと共同で作成したものになります。
間違っている点などがございましたら、指摘してくださると幸いです😢
:::

# はじめに

TypeScript を書いていると、  
「オブジェクトの一部だけを更新したい」「すべてのプロパティが揃っていない状態を表現したい」  
といった場面によく遭遇します。

そんなときに登場するのが **`Partial<T>` 型** です。

本記事では、

- `Partial` 型の基本
- 内部的な仕組み
- よくある使用例（更新処理）
- **Computed Property Names（変数をキーにする `[]`）との組み合わせ**

までを解説します。

---

# Partial 型とは

`Partial<T>` は **型 `T` が持つすべてのプロパティを optional（任意）に変換する** ユーティリティ型です。

```ts
type Partial<T> = {
  [P in keyof T]?: T[P];
};
````

---

# 基本例

```ts
type User = {
  id: number;
  name: string;
  email: string;
};

type PartialUser = Partial<User>;
```

これは次と同じ意味になります。

```ts
type PartialUser = {
  id?: number;
  name?: string;
  email?: string;
};
```

---

# なぜ Partial が必要なのか

## 更新処理との相性が良い

```ts
function updateUser(id: number, data: Partial<User>) {
  // dataには更新したい項目だけ入る
}

updateUser(1, { name: "Taro" });
updateUser(1, { email: "taro@example.com" });
```

* `User` 型そのままだと全プロパティが必須
* `Partial<User>` にすることで「差分更新」が自然に表現できる

---

# Partial を使う際の注意点

## undefined を常に考慮する必要がある

```ts
const user: Partial<User> = {};

user.name.toUpperCase(); // ❌ コンパイルエラー
```

`name` は `string | undefined` になるため、ガードが必要です。

```ts
if (user.name) {
  user.name.toUpperCase(); // ✅
}
```

---

# Computed Property Names とは

**Computed Property Names** とは、
**変数の値をオブジェクトのキーとして使う記法**のことです。

```ts
const key = "name";

const obj = {
  [key]: "Taro",
};
```

これは以下と同じ意味になります。

```ts
const obj = {
  name: "Taro",
};
```

---

# Partial × Computed Property Names

この2つは **更新処理で非常によく一緒に使われます**。

## 例：動的にフィールドを更新する

```ts
function updateField<K extends keyof User>(
  key: K,
  value: User[K]
): Partial<User> {
  return {
    [key]: value,
  };
}
```

使用例：

```ts
const updatedName = updateField("name", "Hanako");
// { name: "Hanako" }

const updatedEmail = updateField("email", "hana@example.com");
// { email: "hana@example.com" }
```

ここで重要なのは、

* `[key]` によって動的なキー指定が可能
* 戻り値を `Partial<User>` にすることで型安全を保っている

という点です。

---

# Partial を使わないとどうなるか

```ts
function updateField<K extends keyof User>(
  key: K,
  value: User[K]
): User {
  return {
    [key]: value,
  };
}
```

❌ これはエラーになります。

理由：

* `User` 型は `id`, `name`, `email` をすべて要求する
* 実際に返しているのは一部のプロパティだけ

👉 **ここで `Partial<User>` が必要になる**わけです。

---

# よく使われる関連ユーティリティ型

| 型             | 役割              |
| ------------- | --------------- |
| `Partial<T>`  | すべてのプロパティを任意にする |
| `Required<T>` | すべてのプロパティを必須にする |
| `Readonly<T>` | 読み取り専用にする       |
| `Pick<T, K>`  | 指定したプロパティだけ取り出す |
| `Omit<T, K>`  | 指定したプロパティを除外する  |

---

# まとめ

* `Partial<T>` は「一部のプロパティだけを扱う」ための型
* 更新処理・差分更新・未完成オブジェクトと相性が良い
* **Computed Property Names と組み合わせると、動的かつ型安全な更新処理が書ける**
* ただし `undefined` を含む点には常に注意する

`Partial` を正しく使えるようになると、
TypeScript での設計の自由度と安全性が一段上がります 🚀