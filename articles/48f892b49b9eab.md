---
title: "TypeScriptで定数と型を安全に管理するパターン（as const / typeof / Record）"
emoji: "🧩"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["TypeScript", "型安全", "フロントエンド", "設計"]
published: true
---

# はじめに

TypeScript で開発していると、

- 「文字列の定数を安全に扱いたい」
- 「型と実装の二重管理を避けたい」
- 「enum は少し重い・扱いづらい」

と感じる場面がよくあります。

この記事では、そうした悩みを解決する**よく使われる定数定義パターン**として、

- `as const`
- `typeof` + `keyof`
- `Record<K, V>`

を組み合わせた設計について、段階的に解説します。

---

# 今回扱うコード

まずは完成形を見ておきます。

```ts
export const TILE_TYPE = {
  FLOOR: 'floor',
  WALL: 'wall',
  HOLE: 'hole',
  KEY: 'key',
  TELEPORT_UP: 'teleportUp',
  TELEPORT_DOWN: 'teleportDown',
  START: 'start',
  GOAL: 'goal',
} as const;

export type TileType = (typeof TILE_TYPE)[keyof typeof TILE_TYPE];

export const TILE_LABELS: Record<TileType, string> = {
  [TILE_TYPE.FLOOR]: '床',
  [TILE_TYPE.WALL]: '壁',
  [TILE_TYPE.HOLE]: '穴',
  [TILE_TYPE.KEY]: 'カギ',
  [TILE_TYPE.TELEPORT_UP]: '上へのテレポート',
  [TILE_TYPE.TELEPORT_DOWN]: '下へのテレポート',
  [TILE_TYPE.START]: 'スタート',
  [TILE_TYPE.GOAL]: 'ゴール',
};
````

一見少し難しそうですが、仕組みが分かると非常に合理的な書き方です。

---

# `as const` とは何か

```ts
const TILE_TYPE = {
  FLOOR: 'floor',
  WALL: 'wall',
} as const;
```

`as const` を付けることで、TypeScript は次のように推論します。

* 値が `string` ではなく **文字列リテラル型**になる
* すべて `readonly` になる

```ts
{
  readonly FLOOR: "floor";
  readonly WALL: "wall";
}
```

これにより、

* 実行時はただの定数オブジェクト
* 型レベルでは厳密なリテラル集合

という状態を同時に得られます。

---

# `typeof` と `keyof` の組み合わせ

## `typeof TILE_TYPE`

```ts
type TileTypeMap = typeof TILE_TYPE;
```

これは「**値として存在する `TILE_TYPE` の型**」を取得します。

```ts
{
  readonly FLOOR: "floor";
  readonly WALL: "wall";
  ...
}
```

---

## `keyof typeof TILE_TYPE`

```ts
keyof typeof TILE_TYPE
```

これはキーの union 型になります。

```ts
"FLOOR" | "WALL" | "HOLE" | ...
```

---

# 値だけを取り出す型定義

```ts
export type TileType =
  (typeof TILE_TYPE)[keyof typeof TILE_TYPE];
```

この書き方は、`TILE_TYPE` の**すべてのキーに対応する値**

を取り出しています。

結果は次の union 型です。

```ts
type TileType =
  | "floor"
  | "wall"
  | "hole"
  | "key"
  | "teleportUp"
  | "teleportDown"
  | "start"
  | "goal";
```

これにより、

* 型定義を別途書く必要がない
* 定数の追加・削除が自動で型に反映される

という大きなメリットがあります。

---

# `Record<K, V>` とは？

`Record` は TypeScript のユーティリティ型で、

```ts
Record<K, V>
```

は次の意味を持ちます。

> **キーが K、値が V のオブジェクト型**

内部的には以下と同じです。

```ts
type Record<K extends PropertyKey, V> = {
  [P in K]: V;
};
```

---

# `Record<TileType, string>` の意味

```ts
export const TILE_LABELS: Record<TileType, string>
```

これは、`TileType` に含まれる **すべての値**をキーとして`string` を値に持つオブジェクトを表します。

つまり、

```ts
{
  floor: string;
  wall: string;
  hole: string;
  key: string;
  teleportUp: string;
  teleportDown: string;
  start: string;
  goal: string;
}
```

が **必ず満たされる** ことを型が保証します。

---

# なぜ `[TILE_TYPE.FLOOR]` と書くのか

```ts
[TILE_TYPE.FLOOR]: '床',
```

これは **computed property name（計算されたプロパティ名）** です。

```ts
[TILE_TYPE.FLOOR] // === 'floor'
```

### 直接 `'floor'` と書かない理由

* タイポを防げる
* 定数の変更に自動追従できる
* 補完が効く

```ts
// NG（ズレやすい）
floor: '床'

// OK（定数参照）
[TILE_TYPE.FLOOR]: '床'
```

---

# `Record` が守ってくれること

## 書き忘れを防ぐ

```ts
Property 'wall' is missing
```

## 余計なキーを防ぐ

```ts
Object literal may only specify known properties
```

## 値の型も保証される

```ts
[TILE_TYPE.HOLE]: 123 // ❌ string ではない
```

👉 **表示定義の抜け漏れをコンパイル時に検出**できます。

---

# switch 文との比較

❌ switch 文の場合：

* case の書き忘れが起きやすい
* 追加時に気づきにくい

```ts
switch (tile) {
  case 'floor': ...
}
```

✅ Record マッピング：

```ts
TILE_LABELS[tile]
```

* O(1)
* 追加・削除は型エラーで検知
* 可読性が高い

---

# この設計が向いている場面

* ゲームや状態管理の種別定義
* ステータス・ロール・権限管理
* UI 表示名や色・アイコンの対応表
* i18n（多言語対応）のキー管理

---

# まとめ

今回のパターンは、

* **実行時の定数**
* **型レベルの安全性**
* **変更への強さ**
* **enum に頼らない軽量設計**

を同時に実現できます。

```ts
export const CONST = { ... } as const;
export type ConstType = (typeof CONST)[keyof typeof CONST];
export const MAP: Record<ConstType, Value> = { ... };
```

TypeScript に慣れてきたタイミングでぜひ取り入れたい、
**長期的に効いてくる設計パターン**です。

---

最後まで読んでいただき、ありがとうございました！