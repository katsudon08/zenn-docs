---
title: "レンダーとは？Reactがコンポーネントを表示するステップ"
emoji: "👀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["React", "レンダー"]
published: true
---
# はじめに

いつも、Reactにおいて、コンポーネントを画面に表示するまでの過程でどのようなプロセスを踏んで描画が行われているかご存じでしょうか？

これらを理解することでコードが実行されるのかを考えたり、ふるまいを説明することができるようになります！

今回は、それらのプロセスについて大まかに触れていこうと思います。

# 大きな3つのステップ

Reactにおいて、コンポーネントが画面に表示されるまでに大きく三つに分かれるステップを踏むことで成り立っています。

1. トリガー
2. レンダー
3. コミット

です。

トリガーはコンポーネントの差異を**伝える**役割
レンダーはコンポーネントを**計算する**役割
コミットはコンポーネントをDOMに**反映させる**役割

となります。

では、続いてそれらを詳しく見ていきましょう。

# トリガーとは

そもそもトリガーとはコンポーネントがレンダーされる**きっかけ**のことです。
以下の2つの種類が存在します。

1. コンポーネントの**初回レンダー**
2. コンポーネントの**state更新**

コンポーネントの初回レンダーはアプリが開始する際にレンダーされるきっかけのことで、`Next.js`などのフレームワークでは隠ぺいされてしまっていますが、ReactではターゲットになるDOMノードに対して`createRoot`を呼び出すことで、作成されたルートの`render`メソッドをコンポーネントに対して呼び出します。

以下は、その例です。

```js
import Image from './Image.js';
import { createRoot } from 'react-dom/client';

const root = createRoot(document.getElementById('root'))
root.render(<Image />);
```

もう一つのトリガーとして、state更新によるものです。
コンポーネントが一番初めにレンダーされた後、`set関数`を用いることでstateを更新し、さらにレンダーをトリガーすることができます。

コンポーネントのstateを更新することで、自動的にレンダーがキューに追加されていきます。
（**キューはデータ構造の一種で、先入れ先出しを持つ構造です**）

# レンダーとは

先ほどのどちらかのパターンでトリガーをすると、Reactはコンポーネントを呼び出すことで画面に表示する内容を把握します。
レンダーとは、Reactが**コンポーネントを呼び出す作業のことを指します**。

初回レンダー時、Reactは**ルートコンポーネント**を呼び出します。

ルートコンポーネントの例は以下のようになります。

```ts
createRoot(document.getElementById('root')!)
```

これに`render`を付け加えることで、コンポーネントを表示します。

次回以降のレンダーでは`state`の更新によってレンダーがトリガーされた関数コンポーネントを、Reactが呼び出します。

これらのプロセスは親コンポーネントが子コンポーネントを持つ場合、それがなくなるまでコンポーネントを返し続けます。
すなわち、Reactはネストされたコンポーネントがなくなり、Reactが画面に表示されるべき内容がすべて分かるまで続きます。

また、再レンダー時にはReactが前回のレンダーからどの部分が変わったのか、あるいは変わらなかったのかを計算します。
この情報は次のコミットフェーズで使用します。

::: message
レンダーは常に同じ入力を受取り、同じ出力を返す**純関数**であるべきとされています。

これを守らず副作用を持つように設計してしまうと、コードベースが複雑になるにつれてバグや予測可能性が低くなります。

これを解決するためにReactが提供している機能で`Strict Mode`という機能を用いて開発することで、事前に防ぐことができます。

`Strict Mode`は2**回呼び出しを行う**ことで、外部とのやり取りがある副作用は壊れ、純関数はただ同じ処理を2回行うだけなので、純粋でない副作用に気づきやすくなります。
:::

# コミットとは

コンポーネントがレンダー（関数として呼び出し）をした後、ReactはDOMに干渉します。

初回レンダー時は、Reactは`appendChild()`DOM APIを使用して、作成したすべてのDOMノードを画面に表示します。

再レンダー時には、Reactはレンダー時に前回との差異を計算した部分のみをDOMノードに適用します。
これにより、一部のみが変更されただけなのにページ全体が再度レンダリングされてしまうような無駄な工程が行われずに済みます。

以下は、公式ドキュメントで用いられている例ですが、`props`に渡される`time`が毎秒変更されるので、`h1`の中身が再度レンダリングされますが、`input`にテキストを入れている状態でもその中身がなくなってしまうようなことはありません。
これは、先ほど説明したレンダー間の差異のみをコミットして画面に表示するためです。

```js
export default function Clock({ time }) {
    return (
        <>
            <h1>{time}</h1>
            <input />
        </>
    );
}

```

また、ReactがDOMを更新した後、ブラウザは画面を再描画するプロセスのおかげで画面に表示されます。
このプロセスは**ブラウザレンダリング**という名称で知られていますが、Reactでは、ドキュメントを通して**ペイント**という名称で呼ばれています。

# 参考

@[card](https://ja.react.dev/learn/render-and-commit)