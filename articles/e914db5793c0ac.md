---
title: "RLE（ランレングス符号化）をわかりやすく解説する"
emoji: "🧵"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["圧縮","アルゴリズム","RLE"]
published: true
---

::: message
本記事はAIと共同で執筆しています。
誤りや、不明瞭な点がありましたらご指摘ください😢
:::

## はじめに

RLE（Run-Length Encoding、ランレングス符号化）は非常に単純で直感的な **可逆圧縮（ロスレス圧縮）** 手法です。  
この記事では初心者にも分かるように「何をするか」「どう動くか」「どんな場面で有効か」「短所は何か」を具体例とコードを交えて説明します。

## RLEとは（概念）

RLEの考え方はとてもシンプルで、**同じ値が連続している部分を「値」と「連続回数（走長）」でまとめる**だけです。  
連続した同じ要素が多ければ多いほど、元データより短く表現できます。

### 文字列イメージ
元データ：
```

AAAAABBBCCDAA

```
RLE（回数＋文字の表現）：
```

5A3B2C1D2A

```
あるいはペア形式なら：
```

(A,5) (B,3) (C,2) (D,1) (A,2)

```

## なぜ使うのか・どんな場面で有効か

- 単色が長く続く画像（モノクロFAX、アイコン、スプライト、単純な図形）  
- 同じ値の塊が多いセンサーデータやログ（状況に依存）  
- 前処理としてRLEで走長を圧縮→さらに別の圧縮アルゴリズムを適用（相補的に使える）

逆にランダムなデータや交互に変化するデータでは効果が薄く、場合によっては**圧縮前よりサイズが増える**ことがあります。

## アルゴリズム（高レベル）

1. データを先頭から順に見る  
2. 直前の値と同じならカウントを増やす  
3. 異なる値になったら `(値, カウント)` を出力し、カウントをリセットする  
4. 最後まで繰り返して最後の走を出力する

計算量は入力長を n として O(n)、追加のメモリは出力の大きさに依存します。

### 擬似コード
```

count = 1
for i = 1 ... len(data)-1:
    if data[i] == data[i-1]:
        count += 1
    else:
        emit (data[i-1], count)
        count = 1
emit (data[last], count)

````

## 実装の注意点（現実的なポイント）

- カウント（走長）の表現幅：1バイトで表すなら最大255まで。長い走は分割して複数ペアにする必要がある。  
- ヘッダやエスケープ：生データに「回数＋値」のフォーマットが混ざる場合、区切りやエスケープを設計する必要がある。  
- 可逆性：RLEは必ず復元可能（元通りに展開できる）であることを確保する。

## 簡単な実装例（Python）

下は分かりやすさ重視の文字列向けエンコード／デコード例です（走長は任意長の整数として扱います）。

```python
def rle_encode(s: str) -> str:
    if not s:
        return ""
    out = []
    count = 1
    prev = s[0]
    for ch in s[1:]:
        if ch == prev:
            count += 1
        else:
            out.append(f"{count}{prev}")
            prev = ch
            count = 1
    out.append(f"{count}{prev}")
    return "".join(out)

def rle_decode(encoded: str) -> str:
    out = []
    num = ""
    for ch in encoded:
        if ch.isdigit():
            num += ch
        else:
            if not num:
                raise ValueError("Invalid format")
            out.append(ch * int(num))
            num = ""
    if num:
        raise ValueError("Invalid format: trailing number")
    return "".join(out)

# 使用例
s = "AAAAABBBCCDAA"
enc = rle_encode(s)  # "5A3B2C1D2A"
dec = rle_decode(enc)  # "AAAAABBBCCDAA"
````

※ バイナリデータではバイト列（`bytes`）を扱い、走長は固定幅（例：1バイト）でパックすることがよくあります。

## 長所・短所（整理）

長所：

* 実装が極めて簡単
* 走長（連続）が長いデータで高い圧縮効率
* 可逆（元に戻せる）

短所：

* 走長が短い・変化が激しいデータでは効果がない、場合によっては膨張する
* 走長の最大値制約（表現幅）に配慮する必要がある
* 高度な統計的圧縮（LZ系、ハフマンなど）には敵わない場面が多い

## 応用例・組み合わせ

* TIFFやBMPの一部はRLEをオプションでサポートしている。
* まずRLEで連続を減らし、その後に一般的な圧縮（gzip, zlib など）をかけると相乗効果が得られる場合がある。
* 画像処理パイプラインで、パレット画像（色数が少ない）に適用すると有利。

## まとめ

RLEは「同じものが続く部分を数えて記録する」非常に基本的な圧縮手法です。
単純故に学習教材や組み込み用途でいまも有用で、特に単色が長く続くメディア（FAX、アイコン、単純な図）で有効です。一方で汎用圧縮には不向きな場面もあるため、データ特性を見て使う・組み合わせる判断が重要です。
