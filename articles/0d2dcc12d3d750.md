---
title: "TypeScriptのExclude型で「使ってはいけない値」を安全に除外する"
emoji: "🧩"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["TypeScript", "型安全", "Exclude", "設計"]
published: true
---

::: message
本記事はAIと共同で執筆しています。
誤りや、不明瞭な点がありましたらぜひご指摘ください😿
:::

## はじめに

TypeScriptで型設計をしていると、

- 「この値だけは使わせたくない」
- 「共通の型から、一部のケースだけを除外したい」
- 「将来の拡張にも強い書き方にしたい」

といった場面に遭遇することがあります。

```ts
export type BasicCommand = {
  type: Exclude<CommandType, 'loop'>;
};
```

本記事では、上記のような型定義を題材にしながら、

* これは**具体的に何をしているのか**
* **なぜこの書き方が有用なのか**
* どんなメリットがあるのか

を順を追って解説します。

---

## 前提：CommandTypeがユニオン型の場合

まずは前提となる型を考えてみます。

```ts
type CommandType =
  | 'start'
  | 'stop'
  | 'pause'
  | 'loop';
```

このように、`CommandType` は「取りうる値の集合（ユニオン型）」として定義されています。

---

## Exclude型とは何か

`Exclude<T, U>` は TypeScript が提供している**ユーティリティ型**のひとつです。

役割はとてもシンプルで、

> **T から U に割り当て可能な型を取り除く**

というものです。

概念的には、以下のような条件型として実装されています。

```ts
type Exclude<T, U> = T extends U ? never : T;
```

ポイントは以下です。

* `T` がユニオン型の場合、**各要素に対して条件が適用される**
* `U` に一致するものは `never` になり、結果から消える
* 一致しないものだけが残る

---

## 今回の型定義がやっていること

では、今回の型定義を見てみます。

```ts
export type BasicCommand = {
  type: Exclude<CommandType, 'loop'>;
};
```

これはつまり、

**`CommandType` の中から`'loop'` だけを除外したものを`type` プロパティとして持つ**

という意味になります。

展開すると、実質的には次の型と同じです。

```ts
type BasicCommand = {
  type: 'start' | 'stop' | 'pause';
};
```

---

## 実際の挙動を例で確認する

```ts
const a: BasicCommand = { type: 'start' }; // OK
const b: BasicCommand = { type: 'pause' }; // OK

const c: BasicCommand = { type: 'loop' };
// ❌ Type '"loop"' is not assignable
```

このように、

* `'loop'` を使った瞬間に **コンパイルエラー**
* 実行前に不正なケースを排除できる

という恩恵があります。

---

## この書き方をする利点

### 1. 型安全性が高まる

「この型では `'loop'` を使ってはいけない」という制約を
**ランタイムではなく型レベルで保証**できます。

結果として、

* 条件分岐の漏れ
* 想定外の値の混入

を未然に防げます。

---

### 2. IDEの補完が賢くなる

`BasicCommand.type` を入力すると、補完候補は

```ts
'start' | 'stop' | 'pause'
```

だけになります。

これは開発体験の向上だけでなく、
**誤用を自然に防ぐUX**としても優秀です。

---

### 3. 設計意図がコードから伝わる

```ts
Exclude<CommandType, 'loop'>
```

という書き方自体が、

> 「CommandType のうち、loop だけは特別扱いしている」

という設計意図をそのまま表現しています。

コメントがなくても、
**型定義そのものがドキュメントになる**のが大きな利点です。

---

### 4. 将来の変更に強い

もし `CommandType` に新しい値が追加されたとしても、

```ts
type CommandType =
  | 'start'
  | 'stop'
  | 'pause'
  | 'loop'
  | 'resume'; // 追加
```

`BasicCommand` 側は何も修正しなくても、

```ts
type: 'start' | 'stop' | 'pause' | 'resume'
```

という形で自動的に反映されます。

**「除外ルール」だけを書いている**ため、保守性が高いです。

---

## 判別共用体との相性

`type` プロパティを識別子とする
**判別共用体（Discriminated Union）** とも非常に相性が良いです。

```ts
type Command =
  | { type: 'start'; payload: number }
  | { type: 'stop' }
  | { type: 'loop'; interval: number };
```

ここから `'loop'` を除外したい場合は、次のように書けます。

```ts
type BasicCommand = Exclude<Command, { type: 'loop' }>;
```

結果：

```ts
// { type: 'start'; payload: number }
// | { type: 'stop' }
```

UI用・API用など、**用途別に安全な型を切り出す**ことができます。

---

## 注意点・落とし穴

* `Exclude` は「U に割り当て可能なもの」をすべて除外する
* `string` や `number` のような広い型に対して使うと効果が薄い
* リテラルユニオンと組み合わせるのが前提

基本的には、

> **値の集合が明確なユニオン型**

に対して使うのがベストです。

---

## まとめ

* `Exclude<T, U>` は **型の集合から特定の要素を取り除く**ための仕組み
* 「使ってはいけないケース」を型で表現できる
* 安全性・可読性・保守性が大きく向上する
* 判別共用体と組み合わせるとさらに強力

TypeScriptの型設計では、

> 「どう実装するか」より
> **「何を許可し、何を禁止するか」**

を型で表すことが重要です。

`Exclude` は、そのための非常に強力な道具のひとつです。