---
title: "Reactのイベント処理を基礎から理解する"
emoji: "🖱️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["React", "イベントハンドラ", "イベントの伝播"]
published: true
---
# 1.はじめに
Reactを書き始めるとき、ボタンなどのアクティブな操作を実装したいなと思ったら必ず最初に触れる「イベント処理」。

`onClick`が動いたり、動かなかったりして混乱した経験はありませんか？

そんな方向けに今回は以下の内容を書いていきたいと思います！

- Reactのイベントハンドラの正しい書き方
- よくあるミス
- イベントの伝播・制御の考え方

# 2.Reactのイベント処理とは
以前にもお話ししましたが、ReactにおけるPropsはすべて**キャメルケース**です。（`camelCase`のようなイメージです）

ですので、イベントハンドラを渡す`onclick`も`onClick`という名前になります。

この`onClick`に関数を**渡す**ことで、ユーザーのアクション（ボタンをクリックなど）に合わせてその関数を発火させることができます。

これがイベントハンドラです。

この設計のおかげで、UIが状態とイベントの2つに分けることができ、再利用可能なコンポーネントを作ることができるようになります。（UIはそのまま、関数を変えるだけみたいな設計ができますよね）

# 3.イベントハンドラの書き方
イベントハンドラとしての書き方は以下の2つです。

1. 関数として渡す
```ts
function handleClick() {
    alert('Clicked')
}

<button onClick={handleClick}>Click</button>
```

2. インライン関数を使う
```ts
<button onClick={() => alert('Clicked')}>Click</button>
```

どちらでも問題ありませんが、基本的には関数を渡す書き方にすると、可読性が向上するのでおすすめです。

また、関数名についてはイベントハンドラの名前は`handle`という文字列を先頭につけるのが慣習になっています。

例）`handleClick`, `handleChange`...

:::message
なぜ関数を渡すときに`handleClick()`ではなく、`handleClick`なのでしょうか？

その答えは実行のタイミングにあります。

```ts
<button onClick={handleClick()}>Click</button>
```

上記のように、`()`がついているとコンポーネントがレンダリングされる際に、即実行されてしまいます。
ボタン側としては、ただ関数を認識して、ボタンを押したときにこの関数を発火させたいのに、すでに実行してしまっている状態になってしまいます。

そうならないように`()`を付けないようにして渡さなければありません。

ここで、疑問が1つ生じます。
引数を持つ関数を書いてしまった場合はどうすればいいの？

これについては、先ほど示したインライン関数でラップする手法を用います。

```ts
// 先ほどからアロー関数により記載していますが、functionを使った書き方でも問題ありません
<button onClick={() => handleClick("text")}>Click</button>
```

これにより、インライン関数自体はレンダリング時に実行されないので中の関数を渡すことが可能です。
:::

# 4.Propsでイベントを渡す
一般的にReactにおけるコンポーネントは再利用性を大事にしています。

つまり、いつでもふるまいを変えてあげれば似たような動作をしてくれるということです。

これを満たすためには親と子のコンポーネントで役割を分担します。

- **親**：ロジックをもつ
- **子**：見た目と親から受け取ったイベントを実行するだけ

```ts
interface ButtonProps {
    onClick: () => void;
    children: ReactNode;
}

function Button({ onClick, children }: ButtonProps) {
    return (
        <button onClick={onClick}>
            {children}
        </button>
    );
}

export default function App() {
    const handleClick = () => {
        alert("text");
    }

    return (
        <div>
            <Button onClick={handleClick}>
                Click
            </Button>
        </div>
    );
}
```

これにより、以下のような利益が得られます。

- テストがしやすい
- UIと処理を分離することができる

# 5.イベントの伝播（バブリング）
イベントが親と子のどちらのコンポーネントにも設定されている場合、どのような挙動をするのでしょうか？

そのカギは**伝播**です。

```ts
<div onClick={() => alert("Parent")}>
    <button onClick={() => alert("Child")}>Click</button>
</div>
```

上記コードにおいて、`div`要素をクリックすると、`Parent`テキストのアラートが表示されるだけですが、`button`要素をクリックすると、`Child`テキストのアラートの後に`Parent`テキストのアラートが表示されます。

つまり、子から親へとイベントは伝播します。

全て実行させたいなら問題ないのですが、たいていはそんな分けわなく、むしろバグを生む原因になります。

じゃぁどうすれば...という方、安心してください。
きちんと解決策があります。

`stopPropagation`という関数がそのカギです。

```ts
<button onClick={e => {
    e.stopPropagation();
    alert("Child only!");
}}/>
```

eとはイベントハンドラが唯一の引数とする**イベントオブジェクト**のことです。（引数名は好きに設定できます）

このオブジェクトに、イベントに関する情報がたくさん詰まっています。

そのうちの1つとして、親への伝播を止める関数が`stopPropagation`です。

:::message
親要素への伝播を止められる`stopPropagation`は便利！

確かにその通りです。

ですが、多用は禁物です。
イベントの伝播（バブリングと呼ばれます）を特定の要素で止めることで、親要素におけるイベントハンドラが期待通りに動かなくなったり、動作が崩壊してしまうリスクがあります。
ですので、きちんとした設計をしてから、使うようにしましょう。
:::

# 6.`preventDefault`について
先ほど触れたイベントハンドラが持つ唯一の引数のイベントオブジェクトにもう一つよく使うものとして`preventDefault`があります。

こちらは、フォーム送信やリンククリックなどのタグ要素が持つデフォルトのブラウザ動作（ページ全体のリロードなど）を無効化したいときに使用します。

```ts
<form onSubmit={(e) => {
    e.preventDefault();
}}>
```

先ほどの`stopPropagation`と混同しないように気を付けましょう！

# 7.まとめ
イベントハンドラは関数を渡して、それをユーザーの操作に合わせて発火します。

関数の副関数は基本的にここへ記載します。
（絶対にJSX自体には混ぜちゃダメ！）

親から子へPropsを用いて渡すのが、基本ですので伝播・制御をきちんと理解した上で使用するように心がけましょう！

# 8.参考
- [イベントへの応答](https://ja.react.dev/learn/responding-to-events)