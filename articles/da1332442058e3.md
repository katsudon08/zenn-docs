---
title: "stateとは？コンポーネントのメモリについて"
emoji: "💾"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["React", "useState"]
published: true
---
# はじめに

ボタンを押したら数字を1つプラスする。
フォームに文字を入力すると、表示内容が更新される。

こういった、ユーザー操作の結果として画面上の表示内容を変更するコンポーネントを作成する際、通常の変数を用いて行おうと思ってもうまくいきません。

なぜなら、Reactは変数の内容について**監視**していないからです。

今回は、Reactでコンポーネントの中の状態を覚えておくために必要な機能について解説していきたいと思います！

# そもそもなぜ変数による管理がダメなのか？

`はじめに`のセクションでも軽く触れたのですが、ボタンを押したら表示されている数字を1増やして再度レンダリングを行うようなよくあるコンポーネントは、通常の変数を用いても実現することができません。

以下は、公式ドキュメントにある例をそのまま持ち出したものです。

```js
import { sculptureList } from "./data.js";

export default function Gallery() {
    let index = 0;

    function handleClick() {
        index = index + 1;
    }

    let sculpture = sculptureList[index];
    return (
        <>
            <button onClick={handleClick}>Next</button>
            <h2>
                <i>{sculpture.name} </i>
                by {sculpture.artist}
            </h2>
            <h3>
                ({index + 1} of {sculptureList.length})
            </h3>
            <img src={sculpture.url} alt={sculpture.alt} />
            <p>{sculpture.description}</p>
        </>
    );
}
```

`sculpture`オブジェクト表示を`index`を変えることで更新しようとしていますね。

確かに、`handleClick`イベントハンドラはボタンを押した際に動作し、indexを1つ増やすのですが、以下の理由からレンダリングに反映されることはありません。

- Reactはローカル変数（通常の`let`や`const`などで定義している変数）を監視していないので、これが変わっても**レンダリングをトリガーすること**がない
- ローカル変数はサイドレンダリングすると状態がリセットされてしまう（例として0 -> 1のように1だけ増やすのだとしたら、常に0スタートとなってしまうので、レンダリングするたびに1が返される）

このようにローカル変数自体はレンダリングに一切かかわりがないどころか、レンダリングの際にリセットされてしまうため、先ほどの例がうまく実現できないのですね。

# じゃぁどうすれば解決できるのか？

`useState`というReactが提供している**フック**を使います。

:::details フックとは？
Reactがレンダーされている間のみ利用可能な特別な関数のことです。
フックにも様々な種類があり、そのうちの1つとして今回説明する`useState`があります。

フックを使うことでReactのいろいろな機能に接続（hook into）できるのでこの名前が付けられたとか。

注意点としては、`use`で始まるこれらフックはコンポーネントのトップレベルか**カスタムフック**と呼ばれる自作のフックの中でのみ呼び出すことができます。

コンポーネントのトップレベルで呼び出す理由としては、Reactはフックを読み込んでから、配列にそれらをどんどん追加して、関連付けているので（**識別子とかで認識してるわけじゃない**）、レンダリングのたびに常に同じ順番で呼び出されるのを利用しているから、トップレベルで宣言しておく必要があるわけですね。
:::

で、さっそく使い方なわけですが以下のようにまず`useState`をインポートします。

```js
import { useState } from 'react';
```

次に、先ほどの`let index = 0`の部分を以下のように書き換えます。

```js
const [index, setIndex] = useState(0);
```

ここで、注意しておきたいのは`useState`は常に2つの値を返すということです。
コンポーネントのメモリとして扱える`state変数`（左）とstate変数を更新してレンダリングのトリガーを通知する`セッタ関数`（右）です。

配列の**分割代入**により、個々の値をきちんと読み取ることができます。

`setIndex`は呼び出すことで、中に入れた引数の値に`index`を更新し、再度レンダリングを起こすことで、画面の表示についても変えることができます。（先ほど抱えていた問題を解決できましたね！）

以下は、最初に示した例を`useState`を用いて書き換えたものです。

```js
import { useState } from "react";
import { sculptureList } from "./data.js";

export default function Gallery() {
    const [index, setIndex] = useState(0);

    function handleClick() {
        setIndex(index + 1);
    }

    let sculpture = sculptureList[index];
    return (
        <>
            <button onClick={handleClick}>Next</button>
            <h2>
                <i>{sculpture.name} </i>
                by {sculpture.artist}
            </h2>
            <h3>
                ({index + 1} of {sculptureList.length})
            </h3>
            <img src={sculpture.url} alt={sculpture.alt} />
            <p>{sculpture.description}</p>
        </>
    );
}
```

これにより、ボタンを押すたびにきちんとindexが1つ増え続け、表示もちゃんと更新されるようになります。

また、今回はコンポーネントの中で1つしか`useState`を用いませんでしたが、本来は複数個用いることもできます。

ですが、あまり数が増えすぎると管理が大変なので、増えすぎたら1つのオブジェクトにまとめて管理したりする方が楽だったりします。

# おまけ

`state`はそれぞれのコンポーネントインスタンスに対してローカルです。
つまり、同じコンポーネントを別々にレンダーしたのなら、それぞれのコンポーネントで別々の独立した`state`を持つことになります。
（片方の`state`を変えても、片方には**影響しない**）

じゃぁ同期させるためにはどうすればいいんだよ！というと、これらのコンポーネントまとめて持つ親のコンポーネントで`useState`を宣言して、そこから`props`として子コンポーネントに`state`を渡してあげることで解決します。

これについては、また今度解説しますね！

# まとめ

レンダー間で情報を記憶させるためには`useState`というフックを使うことで、きちんと表示に反映させることができます！

しっかりと覚えて使っていきましょう！