---
title: "IndexedDBとは？クライアント側で保存するためのもう一つの手段"
emoji: "😊"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Web", "IndexedDB"]
published: true
---
# はじめに

私は普段から、アプリを構築する際にフロントのみで完結させたいとき、又はバックエンドから取得してきたデータをフロント側で一時保存させたいときには`localStorage`を使用していました。

ですが、巨大なオブジェクトやその配列を保存するとなってくると、なかなかに厳しいところがあります。

そんなときの代替手段の1つとして、`IndexedDB`と呼ばれるWebストレージが存在するのを皆さんは知っていますか？

今回は、そんな`IndexedDB`について解説していきたいと思います。

# `IndexedDB`とは？

`IndexedDB`とは名前にDBと入っている通り、データベースの一種です。（ただし、クライアントのもの）
Webブラウザ上で動作し、データを保存・取得・削除ができます。
IndexedDBは以下の特徴を持っています。

- キーと値のペアをデータに保存
- インデックスを作成することによる高速な検索
- **トランザクション**をサポートしているので何が起きてもデータが壊れない
- スキーマのバージョン管理ができる
- ほとんどの操作が**非同期**で行われる

::: details トランザクションとは？
トランザクションとはデータの整合性を守るための、一連の操作のまとまりを指します。

データベースの操作を行う際、それらが中途半端に実行されてデータが壊れてしまうことを防ぐためのとても重要な仕組みとなっています。

トランザクションには4つの原則である**ACID原則**と呼ばれるものがあり、要約すると、処理は独立して一度実行したらすべて実行か実行しないかの2択にすることでデータが壊れることを防ぐものです。また、データは必ず保持され続けます。

<br>

`IndexedDB`でデータを読み書きする際は、前述したとおり必ずトランザクションを介する必要があります。

その流れとしては以下の通りです。

```
範囲を決める > モードを決める > 実行 > 完了
```

1. 範囲（**Scope**）を決める

どのオブジェクトストア（テーブルのようなもの）を操作するか指定

2. モード（**Mode**）を決める

`readonly`か`readwrite`かを選択

3. 実行

データの追加や取得のリクエストを投げる

4. 完了（**Commit**）

全てのリクエストが成功すれば、自動的に確定される

<br>

注意点として、完了（Commit）の性質です。
トランザクションの中で、`fetch`や`await`などの処理をすると、待ち時間の間のブラウザ上のイベントループが空になります。
イベントループが空になると、トランザクションはすべてのリクエストが終わったと判断し、閉じてしまいます！

ですので、必ずトランザクションの外で`await`や`fetch`は行ってからそのデータを中で使うようにしてください。

:::

`IndexedDB`はキーバリューストアという点で、`localStorage`と似ていますが、`localStorage`は文字列のみしか保存できず、5MBという制約がありますが、IndexedDBは値がオブジェクトであり、保存できる容量はPCの空きメモリ量に依存します。

# どうやって使うの？

MDNリファレンスに`IndexedDB API`の使用方法が詳しく書かれているので、ぜひ参照してみてください。

@[card](https://developer.mozilla.org/ja/docs/Web/API/IndexedDB_API)

生のAPIは`IndexedDB`のフローや概念を理解する際にはとても良いのですが、開発に取り組む（特にReactなどの宣言的なもので）に取り入れようとするといろいろな面でボトルネックが生じます。

ですので、`Dexie.js`というライブラリを使います。

# `Dexie.js`とは？

`IndexedDB`をラップしたライブラリで、これを使うことで先ほどのボトルネックを解消することができます。
また、`TypeScript`にも対応しており補完なども含めてばっちりです！

で、ここからが本題なのですが`Dexie v3.2.0`で`LiveQuery`という機能がじっそうされたことにより、リアクティブなDBを実現できるようになりました！

::: details リアクティブなDBって？
一言で表すと、データが変化した瞬間に、それを検知して自動的にUIの更新などを実行してくれる仕組みを持つデータベースのことを指します。

従来のデータベースは、自分からデータを取りに行くのに対して、リアクティブなDBはデータが変わったことを教えてくれるという違いがあります。
:::

# 使い方

まずは、データベースの定義を行います。
`TypeScript`を使用することで、データの型安全性を確保することができます！

```ts
import Dexie, { type EntityTable } from 'dexie';

interface Friend {
    id?: number;
    name: string;
    age: number;
}

const db = new Dexie('MyDatabase') as Dexie & {
    friends: EntityTable<Friend, 'id'>;
}

// スキーマの定義（idを自動増分に設定）
db.version(1).stores({
    friends: '++id, name, age'
});

export { db, type Friend };
```

::: message
データベース定義内で用いられている`&`はインターセクション型と呼ばれるものです。

`|`を使って**どれか**を表すユニオン型と相対的に、インターセクション型は**どれも**を意味します。
すなわち、型を合成して新しい型にするときに使います！

今回の例でいうと、`Dexie`のオブジェクトに加えて`friends`テーブルを追加したオブジェクトを`db`の型として扱います。
:::

続いて、CRUD操作です。

```ts
import { useLiveQuery } from 'dexie-react-hooks';
import { db } from './db';
import { useState } from 'react';

export const FriendManager = () => {
    const [name, setName] = useState('');
    const [age, setAge] = useState(0);

    // 【READ】データの変更を監視して、自動で再レンダリングを行います
    const friends = useLiveQuery(() => db.friends.toArray());

    // 【CREATE】データの追加
    const addFriend = async () => {
        await db.friends.add({name, age});
        setName('');
        setAge(0);
    };

    // 【UPDATE】データの更新
    const celebrateBirthday = async (id: number, currentAge: number) => {
        await db.friends.update(id, { age: currentAge + 1 });
    }

    // 【DELETE】データの削除
    const deleteFriends = async (id: number) => {
        await db.friends.delete(id);
    };

    return {
        <div>
            <h3>Friend List (IndexedDB + Dexie)</h3>
      
            {/* 入力フォーム */}
            <input value={name} onChange={e => setName(e.target.value)} placeholder="Name" />
            <input type="number" value={age} onChange={e => setAge(Number(e.target.value))} />
            <button onClick={addFriend}>Add Friend</button>

            {/* 一覧表示 */}
            <ul>
                {friends?.map(friend => (
                    <li key={friend.id}>
                        {friend.name} ({friend.age}歳)
                        <button onClick={() => celebrateBirthday(friend.id!, friend.age)}>🎂</button>
                        <button onClick={() => deleteFriend(friend.id!)}>Delete</button>
                    </li>
                ))}
            </ul>
        </div>
    }
}
```

::: message
ここで使われている`!`は**非nullアサーション演算子**というものです。

コンパイラに対して、変数などが`null`や`undefined`じゃないから大丈夫ということを示すために使うものです。

ただし、これはコンパイラのエラーをなくすだけで、**実行時の挙動を変えるわけではありません**。
もし、実際に`null`だった場合、実行時にクラッシュしてしまうので注意が必要です。
:::

# まとめ

いかがでしたでしょうか？
localStorageとはまた違ったデータベースよりのクライアントストレージの選択肢である`indexedDB`の使い方を今回はお伝えしました。

状況に合わせて、適切に選択していきたいですね！